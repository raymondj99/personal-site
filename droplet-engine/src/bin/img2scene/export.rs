// export.rs - Write scene data to Rust and TypeScript files

use std::fs::File;
use std::io::{BufWriter, Write};
use std::path::Path;

/// Scene geometry data for export
pub struct SceneGeometry {
    pub depth: Vec<Vec<u8>>,
    pub normal_x: Vec<Vec<i8>>,
    pub normal_y: Vec<Vec<i8>>,
    pub flow_x: Vec<Vec<i8>>,
    pub flow_y: Vec<Vec<i8>>,
    pub ao: Vec<Vec<u8>>,
    pub segments: Vec<Vec<u8>>,
    pub ground: Vec<Vec<u8>>,
}

/// Write Rust source file
pub fn write_rust(path: &Path, palette: &[(u8, u8, u8)], pixels: &[Vec<u8>], geom: &SceneGeometry) {
    let (h, w) = (pixels.len(), pixels.get(0).map_or(0, |r| r.len()));
    let mut f = BufWriter::new(File::create(path).expect("create rust file"));

    writeln!(f, "// Auto-generated by img2scene - do not edit").unwrap();
    writeln!(f, "#![allow(dead_code)]\n").unwrap();
    writeln!(f, "pub const BG_WIDTH: usize = {};", w).unwrap();
    writeln!(f, "pub const BG_HEIGHT: usize = {};", h).unwrap();
    writeln!(f, "pub const BG_PALETTE_SIZE: usize = {};\n", palette.len()).unwrap();

    // Palette
    writeln!(f, "pub static BG_PALETTE: [(u8,u8,u8); BG_PALETTE_SIZE] = [").unwrap();
    for (r, g, b) in palette {
        writeln!(f, "    ({},{},{}),", r, g, b).unwrap();
    }
    writeln!(f, "];\n").unwrap();

    // Arrays
    write_array_u8(&mut f, "BG_PIXELS", pixels);
    write_array_u8(&mut f, "BG_DEPTH", &geom.depth);
    write_array_i8(&mut f, "BG_NORMAL_X", &geom.normal_x);
    write_array_i8(&mut f, "BG_NORMAL_Y", &geom.normal_y);
    write_array_i8(&mut f, "BG_FLOW_X", &geom.flow_x);
    write_array_i8(&mut f, "BG_FLOW_Y", &geom.flow_y);
    write_array_u8(&mut f, "BG_AO", &geom.ao);
    write_array_u8(&mut f, "BG_SEGMENTS", &geom.segments);
    write_array_u8(&mut f, "BG_GROUND", &geom.ground);

    println!("  Generated {}", path.display());
}

/// Write TypeScript source file
pub fn write_ts(path: &Path, palette: &[(u8, u8, u8)], pixels: &[Vec<u8>], geom: &SceneGeometry) {
    let (h, w) = (pixels.len(), pixels.get(0).map_or(0, |r| r.len()));

    // Ensure directory exists
    if let Some(parent) = path.parent() {
        std::fs::create_dir_all(parent).ok();
    }

    let mut f = BufWriter::new(File::create(path).expect("create ts file"));

    writeln!(f, "// Auto-generated by img2scene - do not edit\n").unwrap();
    writeln!(f, "export const BG_WIDTH = {};", w).unwrap();
    writeln!(f, "export const BG_HEIGHT = {};\n", h).unwrap();

    // Palette
    writeln!(f, "export const BG_PALETTE: string[] = [").unwrap();
    for (r, g, b) in palette {
        writeln!(f, "  '#{:02x}{:02x}{:02x}',", r, g, b).unwrap();
    }
    writeln!(f, "];\n").unwrap();

    // Arrays
    write_ts_array_u8(&mut f, "BG_PIXELS", pixels);
    write_ts_array_u8(&mut f, "BG_DEPTH", &geom.depth);
    write_ts_array_i8(&mut f, "BG_NORMAL_X", &geom.normal_x);
    write_ts_array_i8(&mut f, "BG_NORMAL_Y", &geom.normal_y);
    write_ts_array_i8(&mut f, "BG_FLOW_X", &geom.flow_x);
    write_ts_array_i8(&mut f, "BG_FLOW_Y", &geom.flow_y);
    write_ts_array_u8(&mut f, "BG_AO", &geom.ao);
    write_ts_array_u8(&mut f, "BG_SEGMENTS", &geom.segments);
    write_ts_array_u8(&mut f, "BG_GROUND", &geom.ground);

    println!("  Generated {}", path.display());
}

fn write_array_u8<W: Write>(f: &mut W, name: &str, data: &[Vec<u8>]) {
    let (h, w) = (data.len(), data.get(0).map_or(0, |r| r.len()));
    writeln!(f, "pub static {}: [[u8; {}]; {}] = [", name, w, h).unwrap();
    for row in data {
        write!(f, "    [").unwrap();
        for (i, v) in row.iter().enumerate() {
            if i > 0 { write!(f, ",").unwrap(); }
            write!(f, "{}", v).unwrap();
        }
        writeln!(f, "],").unwrap();
    }
    writeln!(f, "];\n").unwrap();
}

fn write_array_i8<W: Write>(f: &mut W, name: &str, data: &[Vec<i8>]) {
    let (h, w) = (data.len(), data.get(0).map_or(0, |r| r.len()));
    writeln!(f, "pub static {}: [[i8; {}]; {}] = [", name, w, h).unwrap();
    for row in data {
        write!(f, "    [").unwrap();
        for (i, v) in row.iter().enumerate() {
            if i > 0 { write!(f, ",").unwrap(); }
            write!(f, "{}", v).unwrap();
        }
        writeln!(f, "],").unwrap();
    }
    writeln!(f, "];\n").unwrap();
}

fn write_ts_array_u8<W: Write>(f: &mut W, name: &str, data: &[Vec<u8>]) {
    writeln!(f, "export const {}: number[][] = [", name).unwrap();
    for row in data {
        write!(f, "  [").unwrap();
        for (i, v) in row.iter().enumerate() {
            if i > 0 { write!(f, ",").unwrap(); }
            write!(f, "{}", v).unwrap();
        }
        writeln!(f, "],").unwrap();
    }
    writeln!(f, "];\n").unwrap();
}

fn write_ts_array_i8<W: Write>(f: &mut W, name: &str, data: &[Vec<i8>]) {
    writeln!(f, "export const {}: number[][] = [", name).unwrap();
    for row in data {
        write!(f, "  [").unwrap();
        for (i, v) in row.iter().enumerate() {
            if i > 0 { write!(f, ",").unwrap(); }
            write!(f, "{}", v).unwrap();
        }
        writeln!(f, "],").unwrap();
    }
    writeln!(f, "];\n").unwrap();
}
